# PHP基础
所有学习记录来自[php官方网站](https://secure.php.net/manual/zh/)

## 数据类型
- boolean（布尔型）
    - `使用关键字 TRUE 或 FALSE。两个都不区分大小写`
- integer（整型）
    - `前面可以加上可选的符号（- 或者 +）`
    - `使用十进制, 十六进制(数字前加0x), 八进制(数字前加0), 二进制(数字前加0b)`
    - `一个数超出了 integer 的范围，将会被解释为 float。`
- float（浮点型, 也称作 double)
    - `当从浮点数转换成整数时，将向下取整。`
    - `echo (int) ( (0.1+0.7) * 10 ); //7` [Why?](https://secure.php.net/manual/zh/language.types.float.php#warn.float-precision)
- string（字符串）
    - `PHP 只能支持 256 的字符集，因此不支持 Unicode`
    - `string 最大可以达到 2GB`
    - `Heredoc 结构 <<<var  &&  Nowdoc 结构 <<<'var' `
    - `Heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的`
    - `复杂（花括号）语法`
    - `可以把 string 当成字符组成的 array`
    - **`字符串会被按照该脚本文件相同的编码方式来编码`**
- array（数组）
    - `key强制转换`[官方说明](https://secure.php.net/manual/zh/language.types.array.php)
    - `数组定义中多个单元都使用了同一个键名，则最后一个覆盖之前的所有。`
    - `方括号和花括号可以互换使用来访问数组单元（例如 $array[42] 和 $array{42} 在上例中效果相同）`
- object（对象）
- resource（资源）
- NULL（无类型）
    - `不区分大小写的常量 NULL`
    - `使用 (unset) $var 将一个变量转换为 null 将不会删除该变量或 unset 其值。仅是返回 NULL 值而已`
- [类型比较表](https://secure.php.net/manual/zh/types.comparisons.php)
- mixed（混合类型）
- number（数字类型）
- callback（回调类型）
    - `在函数中注册有多个回调内容时 (如使用 call_user_func() 与 call_user_func_array())， 如在前一个回调中有未捕获的异常，其后的将不再被调用。`
- $...（伪变量）

## 变量/常量

- `变量名是区分大小写的`
- `由字母或者下划线开头, 正则表达式: '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*' （$this除外）`
- `$GLOBALS  与 global`
- `静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失`
- `可变变量: 一个变量的变量名可以动态的设置和使用`
- `常量默认为大小写敏感。传统上常量标识符总是大写的。常量的范围是全局的。常量的值只能是标量。`
- [魔术常量](https://secure.php.net/manual/zh/language.constants.predefined.php)

## 运算符
- [运算符优先级](https://secure.php.net/manual/zh/language.operators.precedence.php)
- `反引号不能在双引号字符串中使用`

## 流程控制
- `require 和 include 几乎完全一样，除了处理失败的方式不同之外; require 在出错时产生 E_COMPILE_ERROR 级别的错误,脚本停止运行; include 只产生警告（E_WARNING），脚本会继续运行。`
- `require_once 语句和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含, include_once同理。`

## 函数
- `PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。`
- `PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。`
- **`函数名是大小写无关的`** `，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。`
- `传引用的参数也可以有默认值。`
- `如果省略了 return，则返回值为 NULL。`
- `从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &`
- `如果传递给函数的参数类型与实际的类型不一致,通常函数会返回 NULL。`
- `匿名函数，也叫闭包函数，允许临时创建一个没有名称的函数。经常作回调函数参数的值。`
- `闭包可以从父作用域中继承变量。 任何此类变量都应该用 use 语言结构传递进去。`

## 类与对象
- `自动加载类`
- `公有的类成员在任何地方访问。受保护的类成员被其自身,子类和父类访问。私有的类成员只能被其自身的类访问,用var定义，则被视为公有` 
- `用静态方式调用一个非静态方法会导致一个 E_STRICT 级别的错误。`
- `接口中定义的所有方法都必须是公有，这是接口的特性。`
- `实现多个接口时，接口中的方法不能有重名。`
- `接口也可以继承，通过使用 extends 操作符。`
- `接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。`
- `从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。`
- `两个 trait 都插入了同名的方法,as 操作符其中一个方法以另一个名称来引入`
- `内部类只能访问外部公有属性或方法, 内部类可继承外部类`**`(PHP7)`**
- `如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承, 属性不能被定义为 final。`
- `对象比较:(==)比较：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。(===)比较: 这两个对象变量一定要指向某个类的同一个实例（即同一个对象）`
- `后期静态绑定可以用于（但不限于）静态方法的调用, 非静态环境下可以使用 static::` **[重要](https://secure.php.net/manual/zh/language.oop5.late-static-bindings.php)**
- **`对象是通过引用传递的?`**`php的引用是别名，就是两个不同的变量名字指向相同的内容。在php5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。`

## 命名空间
- `名为PHP或php的命名空间，以及以这些名字开头的命名空间（例如PHP\Classes）被保留用作语言内核使用，而不应该在用户空间的代码中使用。`
- `受命名空间的影响: 类（包括抽象类和traits）、接口、函数和常量。`
- `可以在同一个文件中定义多个命名空间`
- `PHP5.6开始允许导入函数或常量或者为它们设置别名。`
- [名称解析规则](https://secure.php.net/manual/zh/language.namespaces.rules.php)

## 异常处理
-   [异常处理类](https://secure.php.net/manual/zh/language.exceptions.extending.php)

## 生成器
- `相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。`
- `一个生成器不可以返回值： 这样做会产生一个编译错误。然而return空是一个有效的语法并且它将会终止生成器继续执行。`